const effects = 
[
    "lrsqueeze",
    "persanticlockrotate",
    "dancechest",
    "snake",
    "legdance",
    "randomdance",
    "moverightside",
    "movingrightsideplus",
    "rightleft",
    "downzeroup",
    "tinyshoulder",
    "tinyshouldermovements",
    "downzeroupdown",
    "leftrightdance",
    "yogaleft",
    "hrithikdance",
    "curvedance",
    "angrybirds",
    "upjump",
    "downzoom",
    "updown",
    "jumpleft",
    "explosion",
    'explosion1',
    "firework",
    "leftbottomzerorighttop",
    "rainbow",
    "zoommove",
    "upzoomdownsmall",
    "neonblue",
    "bothsideclone",
    "bulgepinchreal",
    "gravitybounce",
    "squeezex2",
    "squeezey2",
    "createround",
    "topviewwaterripple",
    "fullleft",
    "clock",
    "butterfly1",
    "twist",
    "tiltsmall",
    "fullupchange",
    "tattoo",
    "lipshape",
    "reallips",
    "parallaxselectedregion",
    "leftVR",
    "leftVR1",
    "rotatey",
    "rotatey3d",
    "leftrightVR",
    "fullimageextend",
    "stonewriting",
    "downchange",
    "sideextension",
    "bodytoashes",
    "whiteline",
    "leftdownzerorightdown",
    "projectile",
    "projectile1",
    'fanceiling',
    'fanceiling1',
    'fanceiling2',
    'fanceilingfast',
    'fanceilingfast1',
    "projectile2",
    "projectile3",
    "projectiletopleft",
    "reverseclock",
    "lefttoprightcircle",
    "infinite",
    "spongeball",
    "downelongate",
    "standing",
    "rightsidesitting",
    "rightsidesitting1",
    "running2",
    "running3",
    "running4",
    "running5",
    "running6",
    "running7",
    "running8",
    "running9",
    "running10",
    "running11",
    "running12",
    "running14",
    "running15",
    "running16",
    "running17",
    "running18",
    "running19",
    "running20",
    "running21",
    "running22",
    "running23",
    "running24",
    "running25",
    "running26",
    "running27",
     "running28",
    "running29",
    "running30",
    "running31",
    "running32",
    "running33",
    "running34",
    "running35",
    "running36",
    "running37",
    "backgroundpredict2",
    "backgroundpredict3",
    "backgroundpredict4",
    "backgroundpredict5",
    "backgroundpredict6",
    "backgroundpredict7",
    "backgroundpredict",
    "background",
    "BHUE",
    "colorchange",
    "blockDissolve1",
    "blockDissolve",
    "bottom10",
    "up10",
    "bottomleft",
    "fullright",
    "bottomright",
    "upright",
    "upleft",
    "brightness1",
    "brightness3",
    "brightness",
    "bulgepinch101",
    "bulgepinch103",
    "bulgepinch104",
    "bulgepinch102",
    "scale",
    "bulgepinch10",
    "bulgePinch1",
    "bulgePinch2",
    "bulgePinch3",
    "bulgePinch4",
    "colorHalfTone",
    "colorUtils",
    "replaceimage1",
    "denoise1",
    "depthAnd3DEffect",
    "depthEstimation",
    "depthMap",
    "dotScreen",
    "down10",
    "downleft10",
    "downright10",
    "droste10",
    "droste11",
    "edgework101",
    "edgework102",
    "edgework10",
    "faceindexmovement1",
    "hexagonalPixelate",
    "hue10",
    "hue1",
    "hue",
    'reallips1',
    'reallips2',
    'reallips3',
    'reallips4',
    'reallips5',
    'reallips6',
    'reallips7',
    'reallips8',
    "indexlips",
    "indexlipsqueeze",
    "indexlipscartoon",
    "outline",
    "ink1",
    "invert",
    "jump",
    "kaleidoscopefullimage",
    "kaleidoscope",
    "left10",
    "right10",
    "lipsync1",
    "lensBlur",
    "lipsync",
    "lipsync10",
    "parallax3d",
    "parallaxdown10",
    "parallaxdownsmall10",
    "parallaxleft10",
    "parallaxleftlarge10",
    "border",
    "parallaxVR10",
    "parallaxleftsmall10",
    "parallaxVR101",
    "perspectiveCubeMap",
    "perspectiveVRcubemap",
    "rotatecentre",
    "perspectiveVRcubemap1",
    "perspectiveVRcubemap2",
    "perspectiveCurve",
    "fullimagesidebyside",
    "perspectiveCurvecopy3",
    "cylinder",
    "perspectiveCylinder",
    "perspectiveEmboss",
    "perspectiveextend",
    "perspectiveField",
    "perspectiveFieldselectedregion",
    "perspectiveFisheye",
    "perspectiveFold",
    "perspectivestepup",
    "perspectiverotate1",
    "perspectiveKaleidoscope",
    "perspectiveMosaic",
    "perspectivePinch",
    "perspectivePinch1",
    "perspectivePosterize",
    "perspectiveRotate",
    "perspectiveSkew",
    "perspectiveSphere",
    "perspectivesqueeze1",
    "perspectiveSqueeze",
    "perspectiveTilt1",
    "perspectiveTilt2",
    "zoom",
    "perspectiveTunnel",
    "perspectiveTwist",
    "perspectiveTwist1",
    "perspectiveVortex",
    "bookfold",
    "perspectiveWarp",
    "perspectiveWave",
    "perspectiveWrap",
    "perspectiveZoom",
    "perspectiveZoom1",
    "posedetection",
    "pp2",
    "mesh",
    "pp3",
    "pp4",
    "pp5",
    "randompic",
    "removebg",
    "rotatebottomleftccw",
    "rotatebottomleftcw",
    "rotatebottomleftvariable",
    "rotatebottomleft",
    "projectileleft",
    "rotatebottomrightccw",
    "projectileleft1",
    "rotatebottomrightcw",
    "rotatebottomright",
    "rotatetopleftccw",
    "rotatetopleftcw",
    "rotatetopleft",
    "rotatetoprightccw",
    "rotatetoprightcw",
    "3d",
    "runninganti",
    "balloon",
    "runningleg2",
    "runningleg3",
    "runningleg4",
    "oscillate",
    "runningleg",
    "running",
    "saturation10",
    "segmentation10",
    "segmentation11",
    "segmentation12",
    "segmentimageselectedregion1",
    "segmentimageselectedregion",
    "sittinganti",
    "sitting",
    "smooth-edges",
    "smoothedgelight",
    "smoothedges2",
    "squeeze1",
    "widen",
    "squeeze2",
    "squeeze3",
    "squeezex1",
    "squeezex",
    "squeezey1",
    "squeezey",
    "swirl",
    "threeDE",
    "droste",
    "running1"
]


const animationEffects = [
    // 'perspectiveTilt', 'perspectiveSqueeze', 'perspectiveCurve', 'perspectiveTwist',
    // 'perspectiveFisheye', 'perspective', 'perspectiveRotate', 'perspectiveSkew',
    // 'perspectiveWarp', 'perspectiveZoom', 'perspectiveTunnel', 'perspectiveSphere',
    // 'perspectiveCylinder', 'perspectiveRipple', 'perspectiveVortex', 'perspectiveFold',
    // 'perspectivePixelate', 'perspectiveEmboss', 'perspectiveMosaic',
    // 'perspectiveOilPainting', 'perspectivePosterize'
];

function toggleAnimationEffects() {
    const animationCheckbox = document.getElementById('animationCheckbox');
    const animationCheckboxLabel = document.getElementById('animationCheckboxLabel');
    const isChecked = animationCheckbox.checked;

    // Update the label text based on the checkbox state
    animationCheckboxLabel.textContent = isChecked ? 'Unselect All' : 'Select All';

    // Toggle all animation effects
    animationEffects.forEach(effect => {
        const checkbox = document.getElementById(effect + 'Checkbox');
        console.log(checkbox); // Should log the checkbox element

        if (checkbox) {
            checkbox.checked = isChecked;
        }
    });

    updateMasterCheckbox();
}

// function toggleAllEffects() {
//     const isChecked = masterCheckbox.checked;
//     effects.forEach(effect => {
//         if (!animationEffects.includes(effect)) {
//             document.getElementById(effect + 'Checkbox').checked = isChecked;
//         }
//     });
// }

function toggleAllEffects() {
    const isChecked = masterCheckbox.checked;
    const searchTerm = effectSearchBar.value.toLowerCase();
    
    effects.forEach(effect => {
        if (!animationEffects.includes(effect)) {
            const checkbox = document.getElementById(effect + 'Checkbox');
            if (checkbox) {
                // Only toggle checkboxes for visible effects (matching search)
                const effectDiv = checkbox.closest('.effect-control');
                if (effectDiv.style.display !== 'none') {
                    checkbox.checked = isChecked;
                }
            }
        }
    });
    
    // Update displayed buttons after toggling checkboxes
    displayEffectButtons();
}

function updateMasterCheckbox() {
    const effectCheckboxes = effects.filter(effect => !animationEffects.includes(effect));
    const allChecked = effectCheckboxes.every(effect => document.getElementById(effect + 'Checkbox').checked);
    const anyChecked = effectCheckboxes.some(effect => document.getElementById(effect + 'Checkbox').checked);
    masterCheckbox.checked = allChecked;
    masterCheckbox.indeterminate = anyChecked && !allChecked;
}

function updateEffectDisplay(effect) {
    const effectButton = document.querySelector(`.effect-button[data-effect="${effect}"]`);
    if (effectButton) effectButton.classList.add('processed');
}

let startTime = 0;
let endTime = 0;
let timerInterval;

function startTimer() {
    startTime = Date.now();
    updateTimer();
    timerInterval = setInterval(updateTimer, 10); // Update every 10ms for smoother display
}

function endTimer() {
    endTime = Date.now();
    clearInterval(timerInterval);
    updateTimer();
}

function updateTimer() {
    const currentTime = endTime || Date.now();
    const elapsedTime = currentTime - startTime;
    
    // Convert to minutes, seconds, and milliseconds
    const minutes = Math.floor(elapsedTime / 60000);
    const seconds = Math.floor((elapsedTime % 60000) / 1000);
    const milliseconds = elapsedTime % 1000;

    // Format the time as MM:SS:mmm
    const displayTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
    
    // Update the timer display
    document.getElementById('timer').textContent = displayTime;
}

// Reset function if needed
function resetTimer() {
    clearInterval(timerInterval);
    startTime = 0;
    endTime = 0;
    document.getElementById('timer').textContent = '00:00:000';
}


function applyEffect(effect, imageData, value, selectedRegions) {
    const startTime = Date.now(); // Record start time when posting to worker
    
    return new Promise((resolve, reject) => {
        if (!workers[effect]) {
            reject(new Error(`Worker for effect ${effect} not found`));
            return;
        }

        workers[effect].onmessage = function(e) {
            const endTime = Date.now(); // Record end time when receiving response
            const executionTime = endTime - startTime;
            
            // Update timer display
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                // Convert to minutes, seconds, milliseconds
                const minutes = Math.floor(executionTime / 60000);
                const seconds = Math.floor((executionTime % 60000) / 1000);
                const milliseconds = executionTime % 1000;
                
                // Format as MM:SS:mmm
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
            }

            if (e.data.error) {
                reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
            } else {
                // console.log('e.data.segmentedImages :>> ', e.data.segmentedImages);
                // console.log(e.data);
                resolve(e.data.segmentedImages[0]); // Updated to match worker response format
            }
        };

        workers[effect].onerror = function(error) {
            const endTime = Date.now();
            const executionTime = endTime - startTime;
            
            // Update timer even in case of error
            const timerElement = document.getElementById('timer');
            if (timerElement) {
                const minutes = Math.floor(executionTime / 60000);
                const seconds = Math.floor((executionTime % 60000) / 1000);
                const milliseconds = executionTime % 1000;
                timerElement.textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${milliseconds.toString().padStart(3, '0')}`;
            }
            
            reject(new Error(`Error in ${effect} worker: ${error.message}`));
        };

        // Send data to the worker
        workers[effect].postMessage({
            imageData: imageData,
            value: value,
            selectedRegions: selectedRegions
        });
    });
}


// function displayEffectButtons() {
//     const searchTerm = effectSearchBar.value.toLowerCase();
    
//     // Clear existing buttons first
//     Array.from(effectControls.children).forEach(child => {
//         if (child.tagName !== 'DIV') {
//             child.remove();
//         }
//     });

//     // Create buttons for filtered effects
//     effects.forEach(effect => {
//         const checkbox = document.getElementById(`${effect}Checkbox`);
//         if (!checkbox || !checkbox.checked) return;

//         const button = document.createElement('button');
//         button.className = 'effect-button';
//         button.textContent = effect;
//         button.dataset.effect = effect;
//         button.dataset.active = 'true';
        
//         // Check if effect matches search term
//         if (searchTerm && !effect.toLowerCase().includes(searchTerm)) {
//             button.style.display = 'none';
//         }

//         button.addEventListener('mouseenter', () => displayEffectImages(effect));
//         button.addEventListener('click', () => {
//             toggleEffect(button);
//             displayEffectImages(effect);
//         });

//         const checkboxDiv = checkbox.closest('.effect-control');
//         checkboxDiv.insertAdjacentElement('afterend', button);
//     });
// }


function displayEffectButtons() {
    const searchTerm = effectSearchBar.value.toLowerCase();
    
    // Clear existing buttons first
    Array.from(effectControls.children).forEach(child => {
        if (child.tagName !== 'DIV') {
            child.remove();
        }
    });
    
    // Create buttons for filtered effects
    effects.forEach(effect => {
        const checkbox = document.getElementById(`${effect}Checkbox`);
        if (!checkbox) return;
        
        // Hide the checkbox and label
        const checkboxContainer = checkbox.parentElement;
        if (checkboxContainer) {
            const label = checkboxContainer.querySelector('label');
            if (label) label.style.display = 'none';
            checkbox.style.display = 'none';
        }
        
        const button = document.createElement('button');
        button.className = 'effect-button';
        button.textContent = effect;
        button.dataset.effect = effect;
        button.dataset.active = 'true';
        
        // Check if effect matches search term
        if (searchTerm && !effect.toLowerCase().includes(searchTerm)) {
            button.style.display = 'none';
        }
        
        button.addEventListener('mouseenter', () => displayEffectImages(effect));
        button.addEventListener('click', () => {
            toggleEffect(button);
            displayEffectImages(effect);
        });
        
        const checkboxDiv = checkbox.closest('.effect-control');
        checkboxDiv.insertAdjacentElement('afterend', button);
    });
}

function initializeEffectControls() {
    const effectControls = document.getElementById('effectControls');
    
    effects.forEach(effect => {
        const div = document.createElement('div');
        div.className = 'effect-control';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `${effect}Checkbox`;
        checkbox.checked = true;
        
        const label = document.createElement('label');
        label.htmlFor = `${effect}Checkbox`;
        label.textContent = effect;
        
        div.appendChild(checkbox);
        div.appendChild(label);
        effectControls.appendChild(div);
    });
}

async function fastProcessImage(img, existingGeneratedImages = []) {
    processedImages = {};  
    const imageCount = parseInt(imageCountInput.value);
    displayEffectButtons();

    // Initialize generatedImages if not already defined
    if (!generatedImages) {
        generatedImages = [];
    }

    // Clear generatedImages if there are no existing generated images
    if (existingGeneratedImages.length === 0) {
        generatedImages = [];
    }

    // Convert input image if needed
    const processInputImage = async (inputImg) => {
        if (inputImg instanceof HTMLImageElement) {
            return inputImg;
        } else if (typeof inputImg === 'string' && 
                   (inputImg.startsWith('data:image') || inputImg.startsWith('http'))) {
            return await new Promise((resolve, reject) => {
                const tempImg = new Image();
                tempImg.onload = () => resolve(tempImg);
                tempImg.onerror = reject;
                tempImg.src = inputImg;
            });
        } else if (inputImg && inputImg.imageUrl) {
            return await new Promise((resolve, reject) => {
                const tempImg = new Image();
                tempImg.onload = () => resolve(tempImg);
                tempImg.onerror = reject;
                tempImg.src = inputImg.imageUrl;
            });
        }
        throw new Error('Invalid image format');
    };

    // Process a single image with an effect
    const processImageWithEffect = async (sourceImg, effect, value, sourceType, sourceIndex) => {
        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width;
        canvas.height = sourceImg.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(sourceImg, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        let processedImageData;
        try {
            processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
        } catch (error) {
            console.error(`Error applying effect ${effect}:`, error);
            return null;
        }

        const resultCanvas = document.createElement('canvas');
        resultCanvas.width = sourceImg.width;
        resultCanvas.height = sourceImg.height;
        const resultCtx = resultCanvas.getContext('2d');
        resultCtx.putImageData(processedImageData, 0, 0);

        const processedResult = {
            value: value,
            dataUrl: resultCanvas.toDataURL(),
            sourceType: sourceType,
            sourceIndex: sourceIndex
        };

        // Add to source images for tracking
        sourceImages.push({
            index: value,
            type: `${effect} leg`,
            image: resultCanvas,
            imageUrl: resultCanvas.toDataURL(),
            imageData: processedImageData.data,
            width: processedImageData.width,
            height: processedImageData.height,
            sourceType: sourceType,
            sourceIndex: sourceIndex,
            value: value
        });

        generatedImages.push({
            index: value,
            type: `${effect} leg`,
            image: resultCanvas,
            imageUrl: resultCanvas.toDataURL(),
            imageData: processedImageData.data,
            width: processedImageData.width,
            height: processedImageData.height,
            sourceType: 'original',
            sourceIndex: 0,
            value: value
        });
        
        return processedResult;
    };

    const selectedEffects = effects.filter(effect => 
        document.getElementById(`${effect}Checkbox`).checked
    );

    try {
        
        const processedInputImg = await processInputImage(img);
        
        await Promise.all(selectedEffects.map(async (effect) => {
            processedImages[effect] = [];
            
            // Process original image variations
            const originalPromises = Array(imageCount).fill().map(async (_, i) => {
                const value = getEffectValue(effect, i, imageCount);
                const result = await processImageWithEffect(
                    processedInputImg, 
                    effect, 
                    value, 
                    'original', 
                    0
                );
                if (result) {
                    processedImages[effect].push(result);
                    updateEffectDisplay(effect);
                }
            });

            // Process existing generated images
            const generatedPromises = existingGeneratedImages.map(async (genImg, i) => {
                const processedGenImg = await processInputImage(genImg);
                const value = getEffectValue(effect, i, existingGeneratedImages.length);
                const result = await processImageWithEffect(
                    processedGenImg, 
                    effect, 
                    value, 
                    'generated', 
                    i
                );
                if (result) {
                    processedImages[effect].push(result);
                    updateEffectDisplay(effect);
                }
            });

            await Promise.all([...originalPromises, ...generatedPromises]);
        }));

    } catch (error) {
        console.error('Error in image processing:', error);
    }

    displayProcessedImages();
}

sourceImages = [];


function enterFullscreen(wrapper, img) {
    // Create a fullscreen container
    const fullscreenContainer = document.createElement('div');
    fullscreenContainer.className = 'fullscreen-grid-container';
    fullscreenContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: #000;
        z-index: 9999;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        padding: 20px;
        overflow-y: auto;
    `;

    // Add close button
    const closeButton = document.createElement('button');
    closeButton.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
        </svg>
    `;
    closeButton.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(255, 255, 255, 0.2);
        border: none;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        z-index: 10000;
        transition: background-color 0.3s;
    `;

    // Store animation intervals to clear them later
    const animationIntervals = [];

    // Clone all animations
    effects.forEach(effect => {
        if (animationStatus[effect] && processedImages[effect]?.length > 0) {
            const animationContainer = document.createElement('div');
            animationContainer.className = 'fullscreen-animation-container';
            animationContainer.style.cssText = `
                position: relative;
                width: 100%;
                padding-bottom: 100%; /* Maintain aspect ratio */
                background: #111;
                border-radius: 8px;
                overflow: hidden;
            `;

            // Add effect label
            const label = document.createElement('div');
            label.textContent = effect;
            label.style.cssText = `
                color: white;
                padding: 10px;
                font-size: 16px;
                font-weight: bold;
                text-align: center;
                background: rgba(0, 0, 0, 0.5);
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1;
            `;

            // Create image container for proper positioning
            const imageContainer = document.createElement('div');
            imageContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            `;

            // Create image for animation
            const animImg = new Image();
            animImg.style.cssText = `
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
            `;

            // Start with first frame
            if (processedImages[effect].length > 0) {
                animImg.src = processedImages[effect][0].dataUrl;
            }

            // Add animation
            let currentFrame = 0;
            const intervalId = setInterval(() => {
                if (processedImages[effect] && processedImages[effect].length > 0) {
                    animImg.src = processedImages[effect][currentFrame].dataUrl;
                    currentFrame = (currentFrame + 1) % processedImages[effect].length;
                }
            }, 200);

            animationIntervals.push(intervalId);

            imageContainer.appendChild(animImg);
            animationContainer.appendChild(imageContainer);
            animationContainer.appendChild(label);
            fullscreenContainer.appendChild(animationContainer);
        }
    });

    // Cleanup function to clear all intervals
    function cleanup() {
        if (!document.fullscreenElement) {
            animationIntervals.forEach(interval => clearInterval(interval));
            fullscreenContainer.remove();
            document.removeEventListener('fullscreenchange', cleanup);
        }
    }

    // Add close functionality
    closeButton.addEventListener('click', () => {
        if (document.fullscreenElement) {
            document.exitFullscreen();
        }
    });

    // Listen for fullscreen change
    document.addEventListener('fullscreenchange', cleanup);

    // Add container and button to body
    fullscreenContainer.appendChild(closeButton);
    document.body.appendChild(fullscreenContainer);

    // Enter fullscreen mode
    if (fullscreenContainer.requestFullscreen) {
        fullscreenContainer.requestFullscreen();
    } else if (fullscreenContainer.webkitRequestFullscreen) {
        fullscreenContainer.webkitRequestFullscreen();
    } else if (fullscreenContainer.msRequestFullscreen) {
        fullscreenContainer.msRequestFullscreen();
    }
}


function createWatermarkedFrame(image, logo) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = image.width;
    canvas.height = image.height;
    
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(image, 0, 0);
    

    const logoSize = {
      width: image.width * 0.1,
      height: image.height * 0.05
    };
    
    ctx.drawImage(logo, 
      canvas.width - logoSize.width - 10,
      canvas.height - logoSize.height - 10,
      logoSize.width, 
      logoSize.height
    );
    
    return canvas;
  }
       

  function addDownloadAllButton() {
    // Check if there's already a download all button to avoid duplicates
    if (document.getElementById('download-all-btn')) return;

    // Count available animations
    const availableEffects = effects.filter(effect => 
        animationStatus[effect] && processedImages[effect]?.length > 0
    );
    const animationCount = availableEffects.length;

    // Create the button container
    const buttonContainer = document.createElement('div');
    buttonContainer.className = 'button-container';
    buttonContainer.style.cssText = `
        text-align: center;
        margin: 20px 0;
        width: 100%;
        display: flex;
        justify-content: center;
        gap: 20px; /* Add spacing between buttons */
    `;

    // Create the "Download All Animations" button
    const downloadAllBtn = document.createElement('button');
    downloadAllBtn.id = 'download-all-btn';
    downloadAllBtn.className = 'download-all-btn';
    downloadAllBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download" style="margin-right: 8px;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="7 10 12 15 17 10"/>
            <line x1="12" y1="15" x2="12" y2="3"/>
        </svg>
        Download All Animations (${animationCount})
    `;
    downloadAllBtn.style.cssText = `
        background-color: #4a5568;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 10px 16px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        min-width: 250px;
    `;

    // Disable the button if no animations are available
    if (animationCount === 0) {
        downloadAllBtn.disabled = true;
        downloadAllBtn.style.opacity = '0.5';
        downloadAllBtn.style.cursor = 'not-allowed';
    } else {
        // Hover effect
        downloadAllBtn.onmouseover = () => { downloadAllBtn.style.backgroundColor = '#2d3748'; };
        downloadAllBtn.onmouseout = () => { downloadAllBtn.style.backgroundColor = '#4a5568'; };
    }

    // Create the "Fullscreen" button
    const fullscreenBtn = document.createElement('button');
    fullscreenBtn.id = 'fullscreen-btn';
    fullscreenBtn.className = 'fullscreen-btn';
    fullscreenBtn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize" style="margin-right: 8px;">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
        Fullscreen
    `;
    fullscreenBtn.style.cssText = `
        background-color: #4a5568;
        color: white;
        border: none;
        border-radius: 6px;
        padding: 10px 16px;
        font-size: 16px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.2s;
        min-width: 150px;
    `;

    // Hover effect for fullscreen button
    fullscreenBtn.onmouseover = () => { fullscreenBtn.style.backgroundColor = '#2d3748'; };
    fullscreenBtn.onmouseout = () => { fullscreenBtn.style.backgroundColor = '#4a5568'; };

    // Add click handler for fullscreen button
    fullscreenBtn.addEventListener('click', () => {
        enterFullscreen();
    });

    // Create progress element (hidden initially)
    const progressContainer = document.createElement('div');
    progressContainer.id = 'download-progress-container';
    progressContainer.style.cssText = `
        width: 100%;
        max-width: 400px;
        margin: 10px auto 0;
        display: none;
    `;

    const progressBar = document.createElement('div');
    progressBar.id = 'download-progress-bar';
    progressBar.style.cssText = `
        height: 6px;
        width: 0%;
        background-color: #4299e1;
        border-radius: 3px;
        transition: width 0.3s ease;
    `;

    const progressText = document.createElement('div');
    progressText.id = 'download-progress-text';
    progressText.style.cssText = `
        font-size: 12px;
        color: #4a5568;
        margin-top: 4px;
        text-align: center;
    `;

    progressContainer.appendChild(progressBar);
    progressContainer.appendChild(progressText);

    // Add click handler for download all button
    downloadAllBtn.addEventListener('click', () => handleDownloadAllAnimations(progressBar, progressText, progressContainer));

    // Add buttons to the container
    buttonContainer.appendChild(downloadAllBtn);
    buttonContainer.appendChild(fullscreenBtn);
    buttonContainer.appendChild(progressContainer);

    // Insert at the top of the results container
    resultsContainer.insertBefore(buttonContainer, resultsContainer.firstChild);
}


// Function to handle downloading all animations
async function handleDownloadAllAnimations(progressBar, progressText, progressContainer) {
    const btn = document.getElementById('download-all-btn');
    const originalContent = btn.innerHTML;
    
    // Show loading state
    btn.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2 animate-spin">
            <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
        </svg>
        Preparing download...
    `;
    btn.disabled = true;
    
    // Show progress container
    progressContainer.style.display = 'block';
    
    try {
        // Get all effects with completed animations
        const availableEffects = effects.filter(effect => 
            animationStatus[effect] && processedImages[effect]?.length > 0
        );
        
        if (availableEffects.length === 0) {
            throw new Error('No animations available to download');
        }
        
        // Start timing
        const startTime = Date.now();
        
        // Calculate total number of frames to process
        const totalFrames = availableEffects.reduce((total, effect) => {
            return total + processedImages[effect].length;
        }, 0);
        
        // Load the logo once for all animations
        progressText.textContent = 'Loading resources...';
        const logo = await new Promise((resolve, reject) => {
            const logoImg = new Image();
            logoImg.crossOrigin = "anonymous";
            logoImg.onload = () => resolve(logoImg);
            logoImg.onerror = reject;
            logoImg.src = 'logo1.jpg';
        });
        
        // Track processed frames
        let processedFrames = 0;
        let completedGifs = 0;
        
        // Update both progress text and progress bar
        const updateProgress = (additionalFrames, completedGif = false) => {
            processedFrames += additionalFrames;
            if (completedGif) completedGifs++;
            
            const percentComplete = Math.min(95, (processedFrames / totalFrames) * 100);
            progressBar.style.width = `${percentComplete}%`;
            
            // Calculate estimated time remaining
            const elapsedTime = (Date.now() - startTime) / 1000; // in seconds
            const framesPerSecond = processedFrames / elapsedTime;
            const remainingFrames = totalFrames - processedFrames;
            
            let estimatedSecondsRemaining = remainingFrames / framesPerSecond;
            if (!isFinite(estimatedSecondsRemaining) || isNaN(estimatedSecondsRemaining)) {
                estimatedSecondsRemaining = 0;
            }
            
            const minutes = Math.floor(estimatedSecondsRemaining / 60);
            const seconds = Math.floor(estimatedSecondsRemaining % 60);
            
            const timeText = minutes > 0 
                ? `${minutes}m ${seconds}s remaining` 
                : `${seconds}s remaining`;
            
            progressText.textContent = `Processing ${completedGifs}/${availableEffects.length} animations (${timeText})`;
        };
        
        // Create a zip file
        const zip = new JSZip();
        btn.innerHTML = `Processing animations...`;
        
        // Create a worker pool for parallel processing
        const maxConcurrentWorkers = Math.min(4, availableEffects.length);
        const queue = [...availableEffects];
        const results = [];
        const activePromises = [];
        
        // Process queue with limited concurrency
        async function processQueue() {
            while (queue.length > 0) {
                const effect = queue.shift();
                
                // Process this effect
                const promise = new Promise(async (resolve, reject) => {
                    try {
                        const frames = processedImages[effect].length;
                        const gif = new GIF({
                            workers: 2,
                            quality: 10,
                            width: processedImages[effect][0]?.width || 400,
                            height: processedImages[effect][0]?.height || 300,
                            background: '#FFFFFF'
                        });
                        
                        // Track progress within this GIF
                        let framesAdded = 0;
                        
                        // Load all images for this effect
                        const loadedImages = await Promise.all(
                            processedImages[effect].map(imageData => {
                                return new Promise((imgResolve) => {
                                    const tempImg = new Image();
                                    tempImg.onload = () => {
                                        framesAdded++;
                                        if (framesAdded % 5 === 0 || framesAdded === processedImages[effect].length) {
                                            updateProgress(5);
                                        }
                                        imgResolve(tempImg);
                                    };
                                    tempImg.src = imageData.dataUrl;
                                });
                            })
                        );
                        
                        // Add frames to GIF
                        loadedImages.forEach(loadedImg => {
                            const canvas = createWatermarkedFrame(loadedImg, logo);
                            gif.addFrame(canvas, { delay: 200 });
                        });
                        
                        // Render the GIF
                        gif.on('finished', blob => {
                            updateProgress(0, true);
                            resolve({
                                effect: effect,
                                blob: blob
                            });
                        });
                        
                        gif.on('error', error => {
                            console.error(`Error creating GIF for ${effect}:`, error);
                            reject(error);
                        });
                        
                        gif.render();
                    } catch (error) {
                        reject(error);
                    }
                });
                
                activePromises.push(promise);
                
                // If we're at max concurrency, wait for one to finish
                if (activePromises.length >= maxConcurrentWorkers) {
                    try {
                        const result = await Promise.race(activePromises);
                        const index = activePromises.findIndex(p => p.then(() => result));
                        if (index !== -1) {
                            activePromises.splice(index, 1);
                        }
                        results.push(result);
                    } catch (error) {
                        console.error('Error in worker:', error);
                    }
                }
            }
            
            // Wait for remaining promises to complete
            try {
                const finalResults = await Promise.allSettled(activePromises);
                finalResults.forEach(result => {
                    if (result.status === 'fulfilled') {
                        results.push(result.value);
                    }
                });
            } catch (error) {
                console.error('Error in final processing:', error);
            }
            
            return results;
        }
        
        // Process the queue and get results
        const successfulResults = await processQueue();
        
        if (successfulResults.length === 0) {
            throw new Error('Failed to generate any animations');
        }
        
        // Add each successful GIF to the ZIP file
        successfulResults.forEach(result => {
            zip.file(`${result.effect}-animation.gif`, result.blob);
        });
        
        // Update status
        btn.innerHTML = `Creating ZIP file...`;
        progressText.textContent = 'Finalizing ZIP file...';
        progressBar.style.width = '98%';
        
        // Generate and download the zip file
        const zipBlob = await zip.generateAsync({type: 'blob', 
            compression: "DEFLATE",
            compressionOptions: {
                level: 5
            }
        });
        
        progressBar.style.width = '100%';
        progressText.textContent = 'Download complete!';
        
        const zipUrl = URL.createObjectURL(zipBlob);
        const a = document.createElement('a');
        a.href = zipUrl;
        a.download = 'all-animations.zip';
        document.body.appendChild(a);
        a.click();
        
        setTimeout(() => {
            document.body.removeChild(a);
            URL.revokeObjectURL(zipUrl);
        }, 100);
        
        // Show success message
        btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-check">
                <polyline points="20 6 9 17 4 12"/>
            </svg>
            Downloaded ${successfulResults.length} animations!
        `;
        
        // Reset after a moment
        setTimeout(() => {
            btn.innerHTML = originalContent;
            btn.disabled = false;
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
        }, 3000);
        
    } catch (error) {
        console.error('Error creating animations package:', error);
        
        // Show error state
        btn.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-circle">
                <circle cx="12" cy="12" r="10"/>
                <line x1="12" y1="8" x2="12" y2="12"/>
                <line x1="12" y1="16" x2="12.01" y2="16"/>
            </svg>
            Error: ${error.message || 'Failed to download'}
        `;
        
        progressText.textContent = 'Download failed. Please try again.';
        progressBar.style.backgroundColor = '#e53e3e';
        
        // Reset after a delay
        setTimeout(() => {
            btn.innerHTML = originalContent;
            btn.disabled = false;
            progressContainer.style.display = 'none';
            progressBar.style.width = '0%';
            progressBar.style.backgroundColor = '#4299e1';
        }, 3000);
    }
}

function displayFinishedAnimations() {
    resultsContainer.innerHTML = ''; // Clear existing content
    addDownloadAllButton();
    // Iterate through all effects
    effects.forEach(effect => {
        if (animationStatus[effect] && processedImages[effect]?.length > 0) {
            // Create a container for the effect
            const container = document.createElement('div');
            container.className = 'effect-container';
            
            // Add a label for the effect
            const label = document.createElement('div');
            label.className = 'effect-label';
            label.textContent = effect; // Use the effect name as the label
            container.appendChild(label);
            
            // Create a wrapper for the animation
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            wrapper.style.position = 'relative'; // Add relative positioning
            
            // Create the image element for the animation
            const img = new Image();
            img.id = `${effect}-image`;
            img.className = 'processed-image';
            
            // Create icon container
            const iconContainer = document.createElement('div');
            iconContainer.className = 'icon-container';
            iconContainer.style.cssText = ``;
            
            // Add the image to the wrapper
            wrapper.appendChild(img);
            
            // Add a download icon
            const downloadIcon = document.createElement('div');
            downloadIcon.className = 'action-icon download-icon';
            downloadIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" >
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            `;

            const shareIcon = document.createElement('div');
            shareIcon.className = 'action-icon share-icon';
            shareIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" >
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
            `;

            const fullscreenIcon = document.createElement('div');
            fullscreenIcon.className = 'action-icon fullscreen-icon';
            fullscreenIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                    <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
                </svg>
            `;

            // Add music icon for MP4 download
            const musicIcon = document.createElement('div');
            musicIcon.className = 'action-icon music-icon';
            musicIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill = "white">
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                </svg>
            `;

            // Add consistent styling for all icons
            const iconStyle = `
            `;

            [downloadIcon, shareIcon, fullscreenIcon, musicIcon].forEach((icon, index) => {
                icon.style.cssText = iconStyle;
                if (index < [downloadIcon, shareIcon, fullscreenIcon, musicIcon].length - 1) {
                    icon.style.marginRight = '8px'; // Add margin to the right of all icons except the last one
                }
                icon.addEventListener('mouseover', () => {
                    icon.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
                });
                icon.addEventListener('mouseout', () => {
                    icon.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
                });
            });

            // Add click handler for download icon
            downloadIcon.addEventListener('click', async () => {
                const originalContent = downloadIcon.innerHTML;
                downloadIcon.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                    </svg>
                `;
                try {
                    // Load the logo
                    const logo = await new Promise((resolve, reject) => {
                        const logoImg = new Image();
                        logoImg.crossOrigin = "anonymous";
                        logoImg.onload = () => resolve(logoImg);
                        logoImg.onerror = reject;
                        logoImg.src = 'logo1.jpg';
                    });
                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: img.naturalWidth || 400,
                        height: img.naturalHeight || 300,
                        background: '#FFFFFF'
                    });
                    // Load all images first
                    const loadedImages = await Promise.all(processedImages[effect].map(imageData => {
                        return new Promise((resolve) => {
                            const tempImg = new Image();
                            tempImg.src = imageData.dataUrl;
                            tempImg.onload = () => resolve(tempImg);
                        });
                    }));
                    // Add frames to the GIF with logo
                    loadedImages.forEach(loadedImg => {
                        const canvas = createWatermarkedFrame(loadedImg, logo);
                        gif.addFrame(canvas, { delay: 200 });
                    });
                    // Render the GIF
                    gif.on('finished', (blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${effect}-animation.gif`;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
                        downloadIcon.innerHTML = originalContent;
                    });
                    gif.render();
                } catch (error) {
                    console.error('Error creating GIF:', error);
                    downloadIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        downloadIcon.innerHTML = originalContent;
                    }, 2000);
                }
            });

            // Add sharing functionality
            let isSharing = false;
            shareIcon.addEventListener('click', async (event) => {
                if (isSharing) {
                    console.log('A share operation is already in progress.');
                    return;
                }
                try {
                    isSharing = true;
                    shareIcon.disabled = true;
                    const originalContent = shareIcon.innerHTML;
                    shareIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                        </svg>
                    `;

                    const logo = await loadWatermarkLogo('logo1.jpg');
                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: img.naturalWidth || 400,
                        height: img.naturalHeight || 300,
                        background: '#FFFFFF'
                    });

                    const loadedImages = await Promise.all(
                        processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
                    );

                    loadedImages.forEach(loadedImg => {
                        const canvas = createWatermarkedFrame(loadedImg, logo);
                        gif.addFrame(canvas, { delay: 200 });
                    });

                    const gifPromise = new Promise((resolve, reject) => {
                        gif.on('finished', resolve);
                        gif.on('error', reject);
                    });
                    gif.render();

                    const blob = await gifPromise;
                    const file = new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });

                    const shareData = {
                        title: 'Check out this animation!',
                        text: `Created using Imaginea. Visit ${window.location.href} for more.`,
                        files: [file]
                    };

                    if (navigator.share && navigator.canShare(shareData)) {
                        await navigator.share(shareData);
                    } else {
                        await navigator.clipboard.writeText(window.location.href);
                        alert('Link copied to clipboard!');
                    }
                } catch (error) {
                    console.error('Error sharing GIF:', error);
                    if (error.name === 'NotAllowedError') {
                        alert('Sharing canceled.');
                    } else if (error.name === 'AbortError') {
                        alert('Sharing was aborted.');
                    } else {
                        alert('Error sharing. Please try again.');
                    }
                } finally {
                    isSharing = false;
                    shareIcon.disabled = false;
                    shareIcon.innerHTML = originalContent;
                }
            });

            // Add fullscreen functionality
            fullscreenIcon.addEventListener('click', () => {
                enterFullscreen(wrapper, img);
            });

            // Add MP4 download functionality with more compatible codec formats
            musicIcon.addEventListener('click', async () => {
                const originalContent = musicIcon.innerHTML;
                musicIcon.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                    </svg>
                `;
                
                try {
                    // Get supported MIME types for recording
                    const getMimeType = () => {
                        const types = [
                            'video/webm',
                            'video/webm;codecs=vp8',
                            'video/mp4',
                            'video/mp4;codecs=h264',
                            'video/x-matroska',
                            'video/webm;codecs=h264'
                        ];
                        
                        for (const type of types) {
                            if (MediaRecorder.isTypeSupported(type)) {
                                console.log(`Using MIME type: ${type}`);
                                return type;
                            }
                        }
                        throw new Error('No supported MIME type found for MediaRecorder');
                    };
                    
                    // Create a canvas element for the video frames
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    console.log(processedImages);
                    console.log(processedImages[effect][0].dataUrl)
                    // Set canvas dimensions to match the image
                    const firstImage = await loadImage(processedImages[effect][0].dataUrl);
                    
function loadImage(dataUrl) {
    return new Promise((resolve) => {
      const tempImg = new Image();
      tempImg.onload = () => resolve(tempImg);
      tempImg.src = dataUrl;
    });
  }
  
                    canvas.width = firstImage.naturalWidth || 400;
                    canvas.height = firstImage.naturalHeight || 300;
                    
                    // Load the logo for watermark
                    const logo = await loadWatermarkLogo('logo1.jpg');

                    // Helper function to load the watermark logo

  function loadWatermarkLogo(logoPath) {
    return new Promise((resolve, reject) => {
        const logoImg = new Image();
        logoImg.crossOrigin = "anonymous";
        logoImg.onload = () => resolve(logoImg);
        logoImg.onerror = reject;
        logoImg.src = logoPath;
    });
}
                  
                    // Load all images
                    const loadedImages = await Promise.all(
                        processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
                    );
                    
                    // Create a MediaRecorder to capture canvas as video
                    const stream = canvas.captureStream(30); // 30 FPS
                    const mimeType = getMimeType();
                    const recorder = new MediaRecorder(stream, {
                        mimeType: mimeType,
                        videoBitsPerSecond: 2500000
                    });
                    
                    const chunks = [];
                    recorder.ondataavailable = (e) => chunks.push(e.data);
                    
                    recorder.onstop = async () => {
                        // Create a Blob from the recorded chunks
                        const blob = new Blob(chunks, { type: mimeType.split(';')[0] });
                        const url = URL.createObjectURL(blob);
                        
                        // Create download link
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${effect}-animation.mp4`;
                        document.body.appendChild(a);
                        a.click();
                        
                        // Clean up
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
                        
                        musicIcon.innerHTML = originalContent;
                    };
                    
                    // Start recording
                    recorder.start();
                    
                    // Draw each frame to the canvas with a delay
                    let frameIndex = 0;
                    function drawNextFrame() {
                        if (frameIndex >= loadedImages.length) {
                            recorder.stop();
                            return;
                        }
                        
                        // Clear canvas
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw image
                        const img = loadedImages[frameIndex];
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                        
                        // Add watermark
                        const logoSize = Math.min(canvas.width, canvas.height) * 0.15;
                        ctx.drawImage(logo, canvas.width - logoSize - 10, canvas.height - logoSize - 10, logoSize, logoSize);
                        
                        frameIndex++;
                        setTimeout(drawNextFrame, 200); // Match the animation speed
                    }
                    
                    // Start drawing frames
                    drawNextFrame();
                    
                } catch (error) {
                    console.error('Error creating MP4:', error);
                    
                    // If MediaRecorder is not supported, offer alternative method
                    if (error.message.includes('MediaRecorder') || error.name === 'NotSupportedError') {
                        alert('Your browser does not support video recording. Generating an animated GIF instead.');
                        
                        try {
                            // Fall back to GIF generation
                            const logo = await loadWatermarkLogo('logo1.jpg');
                            const gif = new GIF({
                                workers: 2,
                                quality: 10,
                                width: img.naturalWidth || 400,
                                height: img.naturalHeight || 300,
                                background: '#FFFFFF'
                            });
                            
                            const loadedImages = await Promise.all(
                                processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
                            );
                            
                            loadedImages.forEach(loadedImg => {
                                const canvas = createWatermarkedFrame(loadedImg, logo);
                                gif.addFrame(canvas, { delay: 200 });
                            });
                            
                            gif.on('finished', (blob) => {
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `${effect}-animation.gif`;
                                document.body.appendChild(a);
                                a.click();
                                setTimeout(() => {
                                    document.body.removeChild(a);
                                    URL.revokeObjectURL(url);
                                }, 100);
                                musicIcon.innerHTML = originalContent;
                            });
                            
                            gif.render();
                            return;
                        } catch (gifError) {
                            console.error('Error falling back to GIF:', gifError);
                        }
                    }
                    
                    musicIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        musicIcon.innerHTML = originalContent;
                    }, 2000);
                }
            });

            // Add all icons to the container
            iconContainer.appendChild(downloadIcon);
            iconContainer.appendChild(shareIcon);
            iconContainer.appendChild(fullscreenIcon);
            iconContainer.appendChild(musicIcon); // Add the music icon to the container
            
            // Add the icon container to the wrapper
            wrapper.appendChild(iconContainer);

            // Add the wrapper to the container
            container.appendChild(wrapper);
            
            // Add the container to the results
            resultsContainer.appendChild(container);
            
            // Animate the images
            let currentFrame = 0;
            function animate() {
                img.src = processedImages[effect][currentFrame].dataUrl;
                currentFrame = (currentFrame + 1) % processedImages[effect].length;
                setTimeout(animate, 200);
            }
            animate();
        }
    });
}

// function displayFinishedAnimations() {
//     resultsContainer.innerHTML = ''; // Clear existing content
//     addDownloadAllButton();
//     // Iterate through all effects
//     effects.forEach(effect => {
//         if (animationStatus[effect] && processedImages[effect]?.length > 0) {
//             // Create a container for the effect
//             const container = document.createElement('div');
//             container.className = 'effect-container';

//             // Add a label for the effect
//             const label = document.createElement('div');
//             label.className = 'effect-label';
//             label.textContent = effect; // Use the effect name as the label
//             container.appendChild(label);

//             // Create a wrapper for the animation
//             const wrapper = document.createElement('div');
//             wrapper.className = 'canvas-wrapper';

//             // Create the image element for the animation
//             const img = new Image();
//             img.id = `${effect}-image`;
//             img.className = 'processed-image';

//             // Add the image to the wrapper
//             wrapper.appendChild(img);

//             // Add a download icon
//             const downloadIcon = document.createElement('div');
//             downloadIcon.className = 'download-icon';
//             downloadIcon.innerHTML = `
//                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download">
//                     <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
//                     <polyline points="7 10 12 15 17 10"/>
//                     <line x1="12" y1="15" x2="12" y2="3"/>
//                 </svg>
//             `;


//             const shareIcon = document.createElement('div');
//             shareIcon.className = 'share-icon';
//             shareIcon.innerHTML = `
//                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share-2">
//                     <circle cx="18" cy="5" r="3"/>
//                     <circle cx="6" cy="12" r="3"/>
//                     <circle cx="18" cy="19" r="3"/>
//                     <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
//                     <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
//                 </svg>
//             `;

//             const fullscreenIcon = document.createElement('div');
//             fullscreenIcon.className = 'fullscreen-icon';
//             fullscreenIcon.innerHTML = `
//                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-maximize">
//                     <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
//                 </svg>
//             `;

//             fullscreenIcon.addEventListener('click', () => {
//                 enterFullscreen(wrapper, img);
//             });

//             wrapper.appendChild(fullscreenIcon);    

//             // Add click handler for download icon
//             downloadIcon.addEventListener('click', async () => {
//                 const originalContent = downloadIcon.innerHTML;
//                 downloadIcon.innerHTML = `
//                     <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2 animate-spin">
//                         <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
//                     </svg>
//                 `;

//                 try {
//                     // Load the logo
//                     const logo = await new Promise((resolve, reject) => {
//                         const logoImg = new Image();
//                         logoImg.crossOrigin = "anonymous";
//                         logoImg.onload = () => resolve(logoImg);
//                         logoImg.onerror = reject;
//                         logoImg.src = 'logo1.jpg';
//                     });

//                     const gif = new GIF({
//                         workers: 2,
//                         quality: 10,
//                         width: img.naturalWidth || 400,
//                         height: img.naturalHeight || 300,
//                         background: '#FFFFFF'
//                     });

//                     // Load all images first
//                     const loadedImages = await Promise.all(processedImages[effect].map(imageData => {
//                         return new Promise((resolve) => {
//                             const tempImg = new Image();
//                             tempImg.onload = () => resolve(tempImg);
//                             tempImg.src = imageData.dataUrl;
//                         });
//                     }));

//                     // Add frames to the GIF with logo
//                     loadedImages.forEach(loadedImg => {
//                         const canvas = document.createElement('canvas');
//                         const ctx = canvas.getContext('2d');

//                         canvas.width = loadedImg.width;
//                         canvas.height = loadedImg.height;
                        
//                         // Fill canvas with white background first
//                         ctx.fillStyle = '#FFFFFF';
//                         ctx.fillRect(0, 0, canvas.width, canvas.height);

//                         // Draw original image
//                         ctx.drawImage(loadedImg, 0, 0);

//                         // Calculate logo size and position
//                         const logoSize = {
//                             width: loadedImg.width * 0.1,
//                             height: loadedImg.height * 0.05
//                         };

//                         const logoPosition = {
//                             x: canvas.width - logoSize.width - 10,
//                             y: canvas.height - logoSize.height - 10
//                         };

//                         // Draw the logo
//                         ctx.drawImage(
//                             logo,
//                             logoPosition.x,
//                             logoPosition.y,
//                             logoSize.width,
//                             logoSize.height
//                         );

//                         // Add the frame to the GIF
//                         gif.addFrame(canvas, { delay: 200 });
//                     });

//                     // Render the GIF
//                     gif.on('finished', (blob) => {
//                         const url = URL.createObjectURL(blob);
//                         const a = document.createElement('a');
//                         a.href = url;
//                         a.download = `${effect}-animation.gif`;
//                         document.body.appendChild(a);
//                         a.click();

//                         setTimeout(() => {
//                             document.body.removeChild(a);
//                             URL.revokeObjectURL(url);
//                         }, 100);

//                         downloadIcon.innerHTML = originalContent;
//                     });

//                     gif.render();
//                 } catch (error) {
//                     console.error('Error creating GIF:', error);
//                     downloadIcon.innerHTML = `
//                         <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-circle">
//                             <circle cx="12" cy="12" r="10"/>
//                             <line x1="12" y1="8" x2="12" y2="12"/>
//                             <line x1="12" y1="16" x2="12.01" y2="16"/>
//                         </svg>
//                     `;
//                     setTimeout(() => {
//                         downloadIcon.innerHTML = originalContent;
//                     }, 2000);
//                 }
//             });


           
         
//             // Add a loading state variable
// let isGenerating = false;

// let isSharing = false; // Track if a share operation is in progress

// shareIcon.addEventListener('click', async (event) => {
//   // Prevent multiple clicks while sharing
//   if (isSharing) {
//     console.log('A share operation is already in progress.');
//     return;
//   }

//   try {
//     isSharing = true; // Set sharing state to true
//     shareIcon.disabled = true; // Disable the share button
//     shareIcon.textContent = 'Generating...'; // Update UI to indicate loading

//     // Load the watermark logo
//     const logo = await loadWatermarkLogo('logo1.jpg');

//     // Initialize GIF
//     const gif = new GIF({
//       workers: 2,
//       quality: 10,
//       width: img.naturalWidth || 400,
//       height: img.naturalHeight || 300,
//       background: '#FFFFFF'
//     });

//     // Load all processed images
//     const loadedImages = await Promise.all(
//       processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
//     );

//     // Process frames and add watermark
//     loadedImages.forEach(loadedImg => {
//       const canvas = createWatermarkedFrame(loadedImg, logo);
//       gif.addFrame(canvas, { delay: 200 });
//     });

//     // Render the GIF
//     const gifPromise = new Promise((resolve, reject) => {
//       gif.on('finished', resolve);
//       gif.on('error', reject);
//     });

//     gif.render();

//     // Wait for the GIF to finish rendering
//     const blob = await gifPromise;
//     const file = new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });

//     // Prepare share data
//     const shareData = {
//       title: 'Check out this animation!',
//       text: `Created using Imaginea. Visit ${window.location.href} for more.`,
//       files: [file]
//     };

//     // Check if sharing is supported and allowed
//     if (navigator.share && navigator.canShare(shareData)) {
//       await navigator.share(shareData);
//     } else {
//       // Fallback: Copy link to clipboard
//       await navigator.clipboard.writeText(window.location.href);
//       alert('Link copied to clipboard!');
//     }

//   } catch (error) {
//     console.error('Error sharing GIF:', error);

//     // Handle specific errors
//     if (error.name === 'NotAllowedError') {
//       alert('Sharing canceled.');
//     } else if (error.name === 'AbortError') {
//       alert('Sharing was aborted.');
//     } else {
//       alert('Error sharing. Please try again.');
//     }
//   } finally {
//     // Reset UI state
//     isSharing = false;
//     shareIcon.disabled = false;
//     shareIcon.textContent = 'Share'; // Reset to original state
//   }
// });



//     async function loadWatermarkLogo(logoPath) {
//         return new Promise((resolve, reject) => {
//         const logo = new Image();
//         logo.crossOrigin = "anonymous";
//         logo.onload = () => resolve(logo);
//         logo.onerror = (error) => reject(new Error(`Failed to load logo: ${error.message}`));
//         logo.src = logoPath;
//         });
//     }

//   async function loadImage(dataUrl) {
//     return new Promise((resolve, reject) => {
//       const img = new Image();
//       img.onload = () => resolve(img);
//       img.onerror = (error) => reject(new Error(`Failed to load image: ${error.message}`));
//       img.src = dataUrl;
//     });
//   }
  

//   function createWatermarkedFrame(image, logo) {
//     const canvas = document.createElement('canvas');
//     const ctx = canvas.getContext('2d');
  
//     canvas.width = image.width;
//     canvas.height = image.height;
  
//     // Fill canvas with white background
//     ctx.fillStyle = '#FFFFFF';
//     ctx.fillRect(0, 0, canvas.width, canvas.height);
  
//     // Draw the original image
//     ctx.drawImage(image, 0, 0);
  
//     // Calculate logo size and position
//     const logoSize = {
//       width: image.width * 0.1,
//       height: image.height * 0.05
//     };
  
//     const logoPosition = {
//       x: canvas.width - logoSize.width - 10,
//       y: canvas.height - logoSize.height - 10
//     };
  
//     // Draw the logo
//     ctx.drawImage(logo, logoPosition.x, logoPosition.y, logoSize.width, logoSize.height);
  
//     return canvas;
//   }

//               // Helper Functions
              
//               function createWatermarkedFrame(image, logo) {
//                 const canvas = document.createElement('canvas');
//                 const ctx = canvas.getContext('2d');
                
//                 // Set canvas dimensions
//                 canvas.width = image.width;
//                 canvas.height = image.height;
                
//                 // Draw white background
//                 ctx.fillStyle = '#FFFFFF';
//                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                
//                 // Draw the main image
//                 ctx.drawImage(image, 0, 0);
                
//                 // Calculate logo dimensions and position
//                 const logoSize = {
//                   width: image.width * 0.1,
//                   height: image.height * 0.05
//                 };
//                 const logoPosition = {
//                   x: canvas.width - logoSize.width - 10,
//                   y: canvas.height - logoSize.height - 10
//                 };
                
//                 // Draw the logo
//                 ctx.drawImage(logo, logoPosition.x, logoPosition.y, logoSize.width, logoSize.height);
                
//                 return canvas;
//               }
              
//               async function createGifFile(blob, effect) {
//                 return new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });
//               }
              
//               async function shareGifContent(file) {
//                 const shareData = {
//                   title: 'Check out this animation!',
//                   text: `Created using Imaginea. Visit ${window.location.href} for more.`,
//                   files: [file]
//                 };
              
//                 if (navigator.share && navigator.canShare(shareData)) {
//                   await navigator.share(shareData);
//                 } else {
//                   // Fallback to clipboard
//                   await navigator.clipboard.writeText(window.location.href);
//                   alert('Link copied to clipboard!');
//                 }
//               }
              
//               function handleError(error) {
//                 console.error('Error sharing GIF:', error);
//                 alert('Sharing failed. Please try again.');
//               }


//             wrapper.appendChild(downloadIcon);
//             wrapper.appendChild(shareIcon);    

//             // Add the wrapper to the container
//             container.appendChild(wrapper);

//             // Add the container to the results
//             resultsContainer.appendChild(container);

//             // Animate the images
//             let currentFrame = 0;
//             function animate() {
//                 img.src = processedImages[effect][currentFrame].dataUrl;
//                 currentFrame = (currentFrame + 1) % processedImages[effect].length;
//                 setTimeout(animate, 200);
//             }
//             animate();
//         }
//     });
// }

async function processImage(img) {

    setInterval(() => {
        displayFinishedAnimations();
    }, 3000);
    
    processedImages = {};
    animationStatus = {};

    const defaultImageCount = parseInt(imageCountInput.value);
    displayEffectButtons();

    const existingGeneratedImages = generatedImages ? [...generatedImages] : [];

    if (!existingGeneratedImages.length) {
        generatedImages = [];
    }
  
    for (const effect of effects.filter(effect => document.getElementById(`${effect}Checkbox`).checked)) {
        processedImages[effect] = [];
        animationStatus[effect] = false; // Mark as not finished initially

        if (existingGeneratedImages && existingGeneratedImages.length > 0) {
            // // console.log(`Processing ${existingGeneratedImages.length} generated images`);
            
            // Process each generated image
            for (let i = 0; i < existingGeneratedImages.length; i++) {
                try {
                    let processedImage;
                    const generatedImg = existingGeneratedImages[i];
                    // // console.log(selectedRegions);
                    // Convert the generated image to HTMLImageElement
                    if (generatedImg instanceof HTMLImageElement) {
                        processedImage = generatedImg;
                        
                    } else if (typeof generatedImg === 'string' && 
                             (generatedImg.startsWith('data:image') || generatedImg.startsWith('http'))) {
                        
                                // // console.log(selectedRegions);
                                        processedImage = await new Promise((resolve, reject) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.onerror = reject;
                            tempImg.src = generatedImg;
                        });
                    } else if (generatedImg && generatedImg.imageUrl) {
                        // // console.log(selectedRegions);
                        processedImage = await new Promise((resolve, reject) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.onerror = reject;
                            tempImg.src = generatedImg.imageUrl;
                        });
                    }

                    if (processedImage) {
                        // Create new canvas and context for this specific generated image
                        const canvas = document.createElement('canvas');
                        canvas.width = processedImage.width;
                        canvas.height = processedImage.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(processedImage, 0, 0);
                        // // console.log(selectedRegions);
                        // Get unique imageData for this generated image
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        // // console.log(selectedRegions)

                        // // console.log(`Processing generated image ${i + 1} with unique imageData`);
                        const value = getEffectValue(effect, i, existingGeneratedImages.length);

                        const processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
                        
                        // Create new canvas for the processed result
                        const resultCanvas = document.createElement('canvas');
                        resultCanvas.width = processedImage.width;
                        resultCanvas.height = processedImage.height;
                        const resultCtx = resultCanvas.getContext('2d');
                        resultCtx.putImageData(processedImageData, 0, 0);
                        // // console.log(selectedRegions);
                        const processedResult = {
                            value: value,
                            dataUrl: resultCanvas.toDataURL(),
                            sourceType: 'generated',
                            sourceIndex: i
                        };
                        animationStatus[effect] = true;
                        // console.log(`Finished processing: ${effect}`);
            
                        processedImages[effect].push(processedResult);
                        // // console.log(selectedRegions);
                        sourceImages.push({
                            index: value,
                            type: `${effect} leg`,
                            image: resultCanvas, // Use the processed canvas
                            imageUrl: resultCanvas.toDataURL(),
                            imageData: processedImageData.data,
                            width: processedImageData.width,
                            height: processedImageData.height,
                            sourceType: 'generated',
                            sourceIndex: i,
                            value: value
                        });
                        // // console.log(selectedRegions);
                        updateEffectDisplay(effect);
                        // // console.log(selectedRegions);
                        // if (Date.now() - processStartTime >= 3000) {
                        //     displayFinishedAnimations();
                        // }
                    }

                    
                } catch (error) {
                    console.error(`Error processing generated image ${i + 1}:`, error);
                }
            }
        } 
        // If no generated images, process original image with variations
        else if (img instanceof HTMLImageElement) {
         
            for (let i = 0; i < defaultImageCount; i++) {
                try {
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    
                    let value = getEffectValue(effect, i, defaultImageCount);
           
                    const processedImageData = await applyEffect(effect, imageData, value, selectedRegions);
                    
                    const resultCanvas = document.createElement('canvas');
                    resultCanvas.width = img.width;
                    resultCanvas.height = img.height;
                    const resultCtx = resultCanvas.getContext('2d');
                    // console.log(processedImageData);
                    resultCtx.putImageData(processedImageData, 0, 0);
                    // // console.log(selectedRegions);
                    const processedResult = {
                        value: value,
                        dataUrl: resultCanvas.toDataURL(),
                        sourceType: 'original',
                        sourceIndex: 0
                    };
                    // // console.log(selectedRegions);
                    animationStatus[effect] = true;
                    console.log(`Finished processing: ${effect}`);
        
                    processedImages[effect].push(processedResult);
                    
                    // Add to generated images for future processing
                    generatedImages.push({
                        index: value,
                        type: `${effect} leg`,
                        image: resultCanvas,
                        imageUrl: resultCanvas.toDataURL(),
                        imageData: processedImageData.data,
                        width: processedImageData.width,
                        height: processedImageData.height,
                        sourceType: 'original',
                        sourceIndex: 0,
                        value: value
                    });
                    // animationStatus[effect] = true;
                    // console.log(`Finished processing: ${effect}`);
        
                    // // console.log(selectedRegions);
                    sourceImages.push({
                        index: value,
                        type: `${effect} leg`,
                        image: resultCanvas,
                        imageUrl: resultCanvas.toDataURL(),
                        imageData: processedImageData.data,
                        width: processedImageData.width,
                        height: processedImageData.height,
                        sourceType: 'original',
                        sourceIndex: 0,
                        value: value
                    });
                    // // console.log(selectedRegions);
                    updateEffectDisplay(effect);

                    // if (Date.now() - processStartTime >= 3000) {
                    //     displayFinishedAnimations();
                    // }
                    
                } catch (error) {
                    console.error(`Error processing original image variation ${i + 1}:`, error);
                }
            }
        }
    }
    
    displayProcessedImages();
}

function displayProcessedImages() {
    // resultsContainer.innerHTML = '';
}

function filterEffects(event) {
    const searchTerm = event.target.value.toLowerCase();
    const effectControls = document.getElementById('effectControls');
    
    effects.forEach(effect => {
        const effectDiv = document.querySelector(`.effect-control:has(#${effect}Checkbox)`);
        const effectButton = document.querySelector(`button[data-effect="${effect}"]`);
        
        if (!effectDiv) return;
        
        if (searchTerm === '') {
            // Show all effects when search is empty
            effectDiv.style.display = '';
            if (effectButton) effectButton.style.display = '';
        } else {
            // Show/hide based on search match
            const matches = effect.toLowerCase().includes(searchTerm);
            effectDiv.style.display = matches ? '' : 'none';
            if (effectButton) effectButton.style.display = matches ? '' : 'none';
        }
    });
}


function convertImageRepresentation(imageRepresentation) {
    return new Promise((resolve, reject) => {
        if (imageRepresentation instanceof HTMLImageElement) {
            resolve(imageRepresentation);
        } else if (typeof imageRepresentation === 'string' && (imageRepresentation.startsWith('data:image') || imageRepresentation.startsWith('http'))) {
            const tempImg = new Image();
            tempImg.onload = () => resolve(tempImg);
            tempImg.onerror = reject;
            tempImg.src = imageRepresentation;
        } else if (imageRepresentation && imageRepresentation.imageUrl) {
            const tempImg = new Image();
            tempImg.onload = () => resolve(tempImg);
            tempImg.onerror = reject;
            tempImg.src = imageRepresentation.imageUrl;
        } else {
            reject(new Error('Invalid image representation'));
        }
    });
}

function stopAnimation(effectId) {
    if (activeAnimations.has(effectId)) {
        clearTimeout(activeAnimations.get(effectId));
        activeAnimations.delete(effectId);
    }
}

function startAnimation(img, images, effectId) {
    let currentFrame = 0;
    
    function animate() {
        if (!document.getElementById(`${effectId}-image`)) {
            stopAnimation(effectId);
            return;
        }
        
        img.src = images[currentFrame].dataUrl;
        currentFrame = (currentFrame + 1) % images.length;
        
        const timeoutId = setTimeout(animate, 200);
        activeAnimations.set(effectId, timeoutId);
    }
    
    animate();
}

function processImageWithMethod(processingMethod) {

    if (!useCredits(1)) {
        return; // Stop if not enough credits
    }
    
    const file = imageUpload.files[0];
    if (file) {
        const objectUrl = URL.createObjectURL(file);
        const img = new Image();
        img.onload = function() {
            URL.revokeObjectURL(objectUrl);
            processingMethod(img);
        }
        img.onerror = function() {
            console.error('Failed to load image');
            alert('Failed to load the selected image.');
        }
        img.src = objectUrl;
    } else if (generatedImages && generatedImages.length > 0) {
        // If no uploaded image but generated images exist
        processingMethod(generatedImages[0]);
    } else {
        alert('Please select an image first.');
    }
}

function toggleEffect(button) {
    button.dataset.active = button.dataset.active === 'true' ? 'false' : 'true';
    button.classList.toggle('inactive');
}

function displayEffectImages(effect) {
    resetHoverTimeout(); // Reset the timeout on hover

    resultsContainer.innerHTML = '';
    
    if (document.getElementById(`${effect}Checkbox`).checked) {
        const images = processedImages[effect];
        
        if (images && images.length > 0) {
            const container = document.createElement('div');
            container.className = 'effect-container';
            
            const wrapper = document.createElement('div');
            wrapper.className = 'canvas-wrapper';
            
            // Updated download icon with white fill
            const downloadIcon = document.createElement('div');
            downloadIcon.className = 'download-icon';
            downloadIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-download">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="7 10 12 15 17 10"/>
                    <line x1="12" y1="15" x2="12" y2="3"/>
                </svg>
            `;
            

            const shareIcon = document.createElement('div');
            shareIcon.className = 'share-icon';
            shareIcon.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-share-2">
                    <circle cx="18" cy="5" r="3"/>
                    <circle cx="6" cy="12" r="3"/>
                    <circle cx="18" cy="19" r="3"/>
                    <line x1="8.59" y1="13.51" x2="15.42" y2="17.49"/>
                    <line x1="15.41" y1="6.51" x2="8.59" y2="10.49"/>
                </svg>
            `;

            wrapper.appendChild(shareIcon); // Add share icon to the wrapper

            const img = new Image();
            img.id = `${effect}-image`;
            img.className = 'processed-image';
            
            wrapper.appendChild(img);
            wrapper.appendChild(downloadIcon);
            
            downloadIcon.addEventListener('click', async () => {
                // Updated loading spinner with white fill
                const originalContent = downloadIcon.innerHTML;
                downloadIcon.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-loader-2 animate-spin">
                        <path d="M21 12a9 9 0 1 1-6.219-8.56"/>
                    </svg>
                `;
            
                try {
                    const logo = await new Promise((resolve, reject) => {
                        const logoImg = new Image();
                        logoImg.crossOrigin = "anonymous";
                        logoImg.onload = () => resolve(logoImg);
                        logoImg.onerror = reject;
                        logoImg.src = 'logo1.jpg';
                    });
            
                    const gif = new GIF({
                        workers: 2,
                        quality: 10,
                        width: img.naturalWidth || 400,
                        height: img.naturalHeight || 300,
                        background: '#FFFFFF'  // Set white background
                    });
            
                    const loadedImages = await Promise.all(images.map(imageData => {
                        return new Promise((resolve) => {
                            const tempImg = new Image();
                            tempImg.onload = () => resolve(tempImg);
                            tempImg.src = imageData.dataUrl;
                        });
                    }));
            
                    loadedImages.forEach(loadedImg => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
            
                        canvas.width = loadedImg.width;
                        canvas.height = loadedImg.height;
                        
                        // Fill canvas with white background first
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
            
                        // Draw original image
                        ctx.drawImage(loadedImg, 0, 0);
            
                        const logoSize = {
                            width: loadedImg.width * 0.1,
                            height: loadedImg.height * 0.05
                        };
            
                        const logoPosition = {
                            x: canvas.width - logoSize.width - 10,
                            y: canvas.height - logoSize.height - 10
                        };
            
                        ctx.drawImage(
                            logo,
                            logoPosition.x,
                            logoPosition.y,
                            logoSize.width,
                            logoSize.height
                        );
            
                        gif.addFrame(canvas, { delay: 200 });
                    });
            
                    gif.on('finished', (blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${effect}-animation.gif`;
                        document.body.appendChild(a);
                        a.click();
            
                        setTimeout(() => {
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                        }, 100);
            
                        downloadIcon.innerHTML = originalContent;
                    });
            
                    gif.render();
            
                } catch (error) {
                    console.error('Error creating GIF:', error);
                    // Updated error icon with white fill
                    downloadIcon.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-alert-circle">
                            <circle cx="12" cy="12" r="10"/>
                            <line x1="12" y1="8" x2="12" y2="12"/>
                            <line x1="12" y1="16" x2="12.01" y2="16"/>
                        </svg>
                    `;
                    setTimeout(() => {
                        downloadIcon.innerHTML = originalContent;
                    }, 2000);
                }
            });

            imageCanvas.addEventListener('mousemove', (event) => {
                const rect = imageCanvas.getBoundingClientRect();
                crosshairX = event.clientX - rect.left;
                crosshairY = event.clientY - rect.top;
                redrawCanvas();
            });


            let isGenerating = false;

shareIcon.addEventListener('click', async (event) => {
  // Prevent multiple clicks while generating
  if (isGenerating) return;
  
  try {
    isGenerating = true;
    // Show loading state
    shareIcon.disabled = true;
    shareIcon.textContent = 'Generating...'; // or update your UI accordingly

    const logo = await loadWatermarkLogo('logo1.jpg');
    
    const gif = new GIF({
      workers: 2,
      quality: 10,
      width: img.naturalWidth || 400,
      height: img.naturalHeight || 300,
      background: '#FFFFFF'
    });

    const loadedImages = await Promise.all(
      processedImages[effect].map(imageData => loadImage(imageData.dataUrl))
    );

    // Process frames
    loadedImages.forEach(loadedImg => {
      const canvas = createWatermarkedFrame(loadedImg, logo);
      gif.addFrame(canvas, { delay: 200 });
    });

    // Create and share the GIF within the same user gesture context
    const gifPromise = new Promise((resolve, reject) => {
      gif.on('finished', resolve);
      gif.on('error', reject);
    });

    gif.render();

    const blob = await gifPromise;
    const file = new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });

    const shareData = {
      title: 'Check out this animation!',
      text: `Created using Imaginea. Visit ${window.location.href} for more.`,
      files: [file]
    };

    if (navigator.share && navigator.canShare(shareData)) {
      await navigator.share(shareData);
    } else {
      await navigator.clipboard.writeText(window.location.href);
      alert('Link copied to clipboard!');
    }

  } catch (error) {
    console.error('Error sharing GIF:', error);
    if (error.name === 'NotAllowedError') {
      alert('Sharing canceled.');
    } else {
      alert('Error sharing. Please try again.');
    }
  } finally {
    // Reset UI state
    isGenerating = false;
    shareIcon.disabled = false;
    shareIcon.textContent = 'Share'; // or reset to original state
  }
});

function loadWatermarkLogo(logoUrl) {
  return new Promise((resolve, reject) => {
    const logoImg = new Image();
    logoImg.crossOrigin = "anonymous";
    logoImg.onload = () => resolve(logoImg);
    logoImg.onerror = reject;
    logoImg.src = logoUrl;
  });
}

function loadImage(dataUrl) {
  return new Promise((resolve) => {
    const tempImg = new Image();
    tempImg.onload = () => resolve(tempImg);
    tempImg.src = dataUrl;
  });
}

function createWatermarkedFrame(image, logo) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  canvas.width = image.width;
  canvas.height = image.height;
  
  ctx.fillStyle = '#FFFFFF';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(image, 0, 0);
  
  const logoSize = {
    width: image.width * 0.1,
    height: image.height * 0.05
  };
  
  ctx.drawImage(logo, 
    canvas.width - logoSize.width - 10,
    canvas.height - logoSize.height - 10,
    logoSize.width, 
    logoSize.height
  );
  
  return canvas;
}
              
              // Helper Functions
     
              function loadImage(dataUrl) {
                return new Promise((resolve) => {
                  const tempImg = new Image();
                  tempImg.onload = () => resolve(tempImg);
                  tempImg.src = dataUrl;
                });
              }
              
              function createWatermarkedFrame(image, logo) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas dimensions
                canvas.width = image.width;
                canvas.height = image.height;
                
                // Draw white background
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw the main image
                ctx.drawImage(image, 0, 0);
                
                // Calculate logo dimensions and position
                const logoSize = {
                  width: image.width * 0.1,
                  height: image.height * 0.05
                };
                const logoPosition = {
                  x: canvas.width - logoSize.width - 10,
                  y: canvas.height - logoSize.height - 10
                };
                
                // Draw the logo
                ctx.drawImage(logo, logoPosition.x, logoPosition.y, logoSize.width, logoSize.height);
                
                return canvas;
              }
              
              async function createGifFile(blob, effect) {
                return new File([blob], `${effect}-animation.gif`, { type: 'image/gif' });
              }
              
              async function shareGifContent(file) {
                const shareData = {
                  title: 'Check out this animation!',
                  text: `Created using Imaginea. Visit ${window.location.href} for more.`,
                  files: [file]
                };
              
                if (navigator.share && navigator.canShare(shareData)) {
                  await navigator.share(shareData);
                } else {
                  // Fallback to clipboard
                  await navigator.clipboard.writeText(window.location.href);
                  alert('Link copied to clipboard!');
                }
              }
              
              function handleError(error) {
                console.error('Error sharing GIF:', error);
                alert('Sharing failed. Please try again.');
              }

            container.appendChild(wrapper);
            resultsContainer.appendChild(container);
            
            let currentFrame = 0;
            
            function animate() {
                img.src = images[currentFrame].dataUrl;
                currentFrame = (currentFrame + 1) % images.length;
                setTimeout(animate, 200);
            }
            
            animate();
        } else {
            resultsContainer.textContent = 'Processing...';
        }
    } else {
        resultsContainer.textContent = 'Effect not selected';
    }
}




// Updated styles for the download icon
const styles = `
.canvas-wrapper {
    position: relative;
    display: inline-block;
}

.download-icon {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 50%;
    padding: 8px;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    transition: all 0.2s ease;
    z-index: 10;
}

.download-icon:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.download-icon:active {
    transform: translateY(0);
}

.download-icon svg {
    display: block;
    color: #4CAF50;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.animate-spin {
    animation: spin 1s linear infinite;
}

.effect-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
}
`;

// Add styles to document
if (!document.getElementById('effect-styles')) {
    const styleElement = document.createElement('style');
    styleElement.id = 'effect-styles';
    styleElement.textContent = styles;
    document.head.appendChild(styleElement);
}


let hoverTimeout;

let activeAnimations = new Map(); // Track active animations


function resetHoverTimeout() {
    clearTimeout(hoverTimeout);
    hoverTimeout = setTimeout(displayAllAnimations, 3000); // 3 seconds
}

function displayAllAnimations() {
    resultsContainer.innerHTML = '';
    
    effects.forEach(effect => {
        if (document.getElementById(`${effect}Checkbox`).checked) {
            const images = processedImages[effect];
            
            if (images && images.length > 0) {
                const container = document.createElement('div');
                container.className = 'effect-container';
                
                 // Add a label for the effect
                 const label = document.createElement('div');
                 label.className = 'effect-label';
                 label.textContent = effect; // Use the effect name as the label
                 container.appendChild(label);
                 
                const wrapper = document.createElement('div');
                wrapper.className = 'canvas-wrapper';
                
                const img = new Image();
                img.id = `${effect}-image`;
                img.className = 'processed-image';
                
                wrapper.appendChild(img);


               
                container.appendChild(wrapper);
                resultsContainer.appendChild(container);
                
                let currentFrame = 0;
                
                function animate() {
                    img.src = images[currentFrame].dataUrl;
                    currentFrame = (currentFrame + 1) % images.length;
                    setTimeout(animate, 200);
                }
                
                animate();
            }
        }
    });
}


function getEffectValue(effect, index, count) {
    const t = index / (count - 1);
    switch(effect) {
        case 'brightness': return Math.floor(t * 510) - 255;
        case 'hue': return Math.floor(t * 360);
        case 'saturation': return t * 2;
        case 'vintage': case 'ink': case 'vibrance': case 'denoise': case 'hexagonalPixelate': case 'invert':
        case 'perspectiveTilt': case 'perspectiveSqueeze': case 'perspectiveCurve': case 'perspectiveFisheye':
        case 'perspectiveRotate': case 'perspectiveSkew': case 'perspectiveWarp': case 'perspectiveZoom':
        case 'perspectiveTunnel': case 'perspectiveSphere': case 'perspectiveCylinder': case 'perspectiveRipple':
        case 'perspectiveVortex': case 'perspectiveFold': case 'perspectivePixelate': case 'perspectiveEmboss':
        case 'perspectiveMosaic': case 'perspectiveOilPainting': case 'perspectivePosterize':
            return t;
        case 'bulgePinch': return [t, t * 2 - 1];
        case 'swirl': return (t - 0.5) * 10;
        case 'lensBlur': case 'triangularBlur': return t * 50;
        case 'tiltShiftBlur': case 'zoomBlur': return [t, 1-t];
        case 'edgeWork': return t * 10 + 1;
        case 'dotScreen': case 'colorHalftone': return t * 10;
        case 'perspectiveTwist': return t * Math.PI * 2;
        case 'perspective': return [t, 1-t, t, 1-t];
        case 'kaleidoscope': return Math.floor(t * 16) + 2;
        case 'wavyDistortion': return [t * 50, (1-t) * 50, t * Math.PI * 2];
        case 'blockDissolve': return Math.floor(t * 20) + 1;
        case 'rgbShift': return [t * 10, (1-t) * 10, t * 10];
        case 'chromaticAberration': return t * 20;
        case 'droste': return [t * 5, (1-t) * 5, t * Math.PI * 2];
        case 'running1': return [
                t * 10,           
                (1-t) * 1,        
                t * Math.PI * 2,  // Leg swing
                (1-t) * Math.PI   // Arm swing
            ];
        case 'running2': return [
            t, // time
            0.5 + t * 1.5, // speed
            0.2 + t * 0.8 // intensity
        ];
        case 'running3': return t;
        case 'running4': return t;
        case 'running5': return t; 
        case 'running6': return t;
        case 'running7': return t;
        case 'running8': return t;
        case 'running9': return t; 
        case 'running10': return t;
        case 'running11': return t;
        case 'running12': return t; 
        case 'running13': return t; 
        default: return t;
    }
}


        function generateBrightnessVariations() {
            const imageCount = parseInt(document.getElementById('imageCount').value);
            const maxBrightness = parseInt(document.getElementById('brightness').value);
            
            const value1 = parseInt(document.getElementById('value1').value);
            const value2 = parseInt(document.getElementById('value2').value);
            const value3 = parseInt(document.getElementById('value3').value);
            const value4 = parseInt(document.getElementById('value4').value);
            const value5 = parseInt(document.getElementById('value5').value);

            const worker = new Worker('js/brightnessWorker.js');
            worker.postMessage({
                imageData: originalImageData,  // Use originalImageData instead of canvas data
                selectedRegions: selectedRegions,
                imageCount: imageCount,
                maxBrightness: maxBrightness,
                value1: value1,
                value2: value2,
                value3: value3,
                value4: value4,

                value5: value5,
                clickedPoints: clickedPoints,
                lines: lines // Add lines array
            });

            worker.onmessage = function(e) {
                // displaySegmentedImages(e.data.segmentedImages);
                if (e.data.error) {
                    reject(new Error(`Error in ${effect} worker: ${e.data.error}`));
                } else {
                    // console.log('e.data.segmentedImages :>> ', e.data.segmentedImages);
                    resolve(e.data.segmentedImages[0]); // Updated to match worker response format
                }
            };
        }

        function displaySegmentedImages(segmentedImages) {
            const container = document.getElementById('generatedImages');
            if (container) {
                container.innerHTML = '';

                const canvas = document.createElement('canvas');
                canvas.width = segmentedImages[0].width;
                canvas.height = segmentedImages[0].height;
                container.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                let currentFrame = 0;

                function animate() {
                    ctx.putImageData(segmentedImages[currentFrame], 0, 0);
                    currentFrame = (currentFrame + 1) % segmentedImages.length;
                    setTimeout(animate, 200); 
                }

                animate();
            } else {
                console.error("Element with ID 'generatedImages' not found.");
            }
        }

    


        
const BODY_PARTS = {
    'left_face': { name: 'Left Face', description: 'Left side of the face' },
    'right_face': { name: 'Right Face', description: 'Right side of the face' },
    'left_upper_arm_front': { name: 'Left Upper Arm (Front)', description: 'Front of left upper arm' },
    'left_upper_arm_back': { name: 'Left Upper Arm (Back)', description: 'Back of left upper arm' },
    'right_upper_arm_front': { name: 'Right Upper Arm (Front)', description: 'Front of right upper arm' },
    'right_upper_arm_back': { name: 'Right Upper Arm (Back)', description: 'Back of right upper arm' },
    'left_lower_arm_front': { name: 'Left Lower Arm (Front)', description: 'Front of left forearm' },
    'left_lower_arm_back': { name: 'Left Lower Arm (Back)', description: 'Back of left forearm' },
    'right_lower_arm_front': { name: 'Right Lower Arm (Front)', description: 'Front of right forearm' },
    'right_lower_arm_back': { name: 'Right Lower Arm (Back)', description: 'Back of right forearm' },
    'left_hand': { name: 'Left Hand', description: 'Left hand' },
    'right_hand': { name: 'Right Hand', description: 'Right hand' },
    'torso_front': { name: 'Torso Front', description: 'Front of the torso' },
    'torso_back': { name: 'Torso Back', description: 'Back of the torso' },
    'left_upper_leg_front': { name: 'Left Upper Leg (Front)', description: 'Front of left thigh' },
    'left_upper_leg_back': { name: 'Left Upper Leg (Back)', description: 'Back of left thigh' },
    'right_upper_leg_front': { name: 'Right Upper Leg (Front)', description: 'Front of right thigh' },
    'right_upper_leg_back': { name: 'Right Upper Leg (Back)', description: 'Back of right thigh' },
    'left_lower_leg_front': { name: 'Left Lower Leg (Front)', description: 'Front of left calf' },
    'left_lower_leg_back': { name: 'Left Lower Leg (Back)', description: 'Back of left calf' },
    'right_lower_leg_front': { name: 'Right Lower Leg (Front)', description: 'Front of right calf' },
    'right_lower_leg_back': { name: 'Right Lower Leg (Back)', description: 'Back of right calf' },
    'left_foot': { name: 'Left Foot', description: 'Left foot' },
    'right_foot': { name: 'Right Foot', description: 'Right foot' },
    'left_upper_foot': { name: 'Left Upper Foot', description: 'Upper part of left foot' },
    'left_lower_foot': { name: 'Left Lower Foot', description: 'Lower part of left foot' },
    'right_upper_foot': { name: 'Right Upper Foot', description: 'Upper part of right foot' },
    'right_lower_foot': { name: 'Right Lower Foot', description: 'Lower part of right foot' }
};
